\section{Secure Multi-party Computation (SMPC)}\label{s:smpc}
Secure multi-party computation (SMPC) \footnote{We are going to use the terms SMPC and MPC interchangeably.} or Secure Function Evaluation (SFE) (in the two-party setting) is a field of cryptography aiming to create methods that enable distinct parties, to jointly compute a function over their private inputs.
Only the outcome of that function is made public and the parties don’t learn anything more than their own input except whatever can be learned from the output of the function.

There are two important requirements on any protocol for secure computation, namely \textit{privacy} and \textit{correctness} \cite{lindell2009secure}.
The privacy requirement suggests that nothing but what is absolutely essential should be learned.
More specifically, all parties should learn nothing more but the computation output.
The correctness requirement states that every party should receive the correct computation output, that is an adversary should not be able to cause the result of the computation to be different than the outcome of the function the parties agreed to compute.

Plenty of tasks can be modeled using SMPC.
The tasks that can be modeled using SMPC include simple ones such as coin tossing, as well as far more complex such as electronic voting, electronic auctions, anonymous transactions, anonymous chatting and private information retrieval systems.

Take electronic voting as an example.
The privacy requirement ensures that no party can learn the individual votes of other parties, while still learning the election outcome.
The correctness requirement ensures that no party can affect the outcome with means other than casting their one individual vote.
Similarly, in the electronic auction example, the privacy requirement ensures that no party learns the bids of other parties while still learning the winning bid. The correctness requirement ensures that no party can bias the auction outcome and that in fact the winning party has places the highest bid.

Secure multi-party computation was introduced in 1982 by Andrew Yao.
Its first form was that of secure two-party computation (2PC) with the so-called Millionaire's Problem \cite{yao1982protocols}.
The problem states that there are two millionaires wishing to know who is richer.
However, they should not find out any additional information about each other’s wealth.
Here the two parties $P_1$, $P_2$ are the two millionaires.
Their private inputs are each one’s wealth $x_1$ and $x_2$ respectively.
The function which they wish to jointly compute can be formulated as

\begin{equation}
  f(x_1, x_2)=\begin{cases}
    x_1, & \text{if $x_1 > x_2$}.\\
    x_2, & \text{otherwise}.
  \end{cases}
\end{equation}

In the general case we have N parties $P_1, P_2, \dots, P_N$ with private inputs $x_1, x_2, \dots, x_N$ respectively.
The goal is to compute a function $f(x_1, x_2, \dots, x_N)$ and learn nothing more than what they would have if a separate trusted party had collected their inputs, and computed function $f$ for them.

Another example for the two-party case is Oblivious Transfer (OT) \cite{rabin2005exchange} with its simples flavor being 1-2 oblivious transfer or ``1 out of 2 oblivious transfer".
Here we have two parties, the sender and the receiver.
The sender has two messages, $m_0$ and $m_1$, and the receiver has a bit $b$.
The receiver wishes to learn $m_b$, without learning anything about $m_{1-b}$ and without the sender learning $b$.

\fixme{Elaborate more..}
