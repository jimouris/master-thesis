\section{Homomorphic Encryption}\label{s:homomorphic-encryption}

Homomorphic encryption enables outsourcing computations to a third party, as for example on the cloud.
Cloud computing is designed to deal with difficult operations and with computationally demanding algorithms.
However, if user's data are unencrypted they can be exposed to attacks from both the cloud provider and third parties.
Even if the data are stored \texttt{(data at rest)} and transferred \texttt{(data in transit)} securely, when they are in use they can be exposed to security risks, such as side-channel attacks \cite{zhang2012cross} and hardware Trojans \cite{becker2013stealthy, tsoutsos2014advanced}.
\texttt{Data at rest} implies data that is stored physically in any digital form, while \texttt{data in transit} means data traversing the network.
Active data under constant change which is stored in a non-persistent digital state typically in computer random access memory (RAM), CPU caches, or CPU registers are called \texttt{data in use}.


It is possible, to construct an entire system to work over encrypted data, manipulating and returning encrypted results.
This system would be based on homomorphic encryption, which allows to apply a function to the ciphertexts that corresponds to another function on the plaintexts, and in general enables computation on encrypted data.
The final results can then be obtained by a single decryption.
For instance, given $E(a)$ and $E(b)$ (the encryption of $a$ and $b$), you can compute $E(a+b)$ without knowing $a$, $b$ nor the decryption key.
The only point in the process where data would be decrypted is when the user wants to see the result, and that would presumably happen in the application or client software, not in the database server in the cloud.


Homomorphic encryption enables computation on data without ever having access to the unencrypted data, rendering the host incapable of leaking any type of information.
There is not a sole type of homomorphic encryption, different schemes have been proposed for different types of applications.
The first was invented in \cite{gentry2009fully} and it is called Fully homomorphic encryption (FHE).
Its appearance sparked the academic interest and there arise a lot of FHE schemes, but unfortunately, they come along with a huge performance overhead.
This overhead has been a concern, despite the wide range of applications that can benefit from FHE schemes, there are not many that leverage FHE.


Another type of homomorphic encryption is partial homomorphic encryption (PHE).
There is a lot of ongoing research, on how to process efficiently encrypted data.
The tremendous expansion in homomorphic encryption applications after 2009 -- when Gentry \textit{et. al.} introduced the first FHE scheme -- include applications such as Helios (e-voting PHE based system) \cite{adida2008helios}, Cryptoleq (Heterogeneous abstract machine for both encrypted and unencrypted computation based on PHE) \cite{mazonka2016cryptoleq}, and others.
All those systems, perform manipulations directly on encrypted data without decrypting them, thus no information leakage is possible.
When the result is eventually decrypted, it will be the same as applying the same manipulations on plaintexts.
Using homomorphic operations requires special care to ensure that branching does not reveal any sensitive data by observing side-channel information (e.g. the branch target).


One challenge that homomorphic encryption schemes, and in general every encrypted computation framework, face is the inability to make runtime decisions based on encrypted data.
For instance, the host is unable to perform operations like ``\texttt{if (x > 0) return;}" when \texttt{x} is an encrypted variable.
This is known as the ``termination problem", introduced in \cite{brenner2011secret}, since performing runtime branch decisions is not possible and therefore rendering the algorithms implemented on top of those systems by design more complex.


To address this problem traditional algorithms must be changed to their homomorphic equivalents, a not straightforward process.
Some work has been done in \cite{mouris2018terminator} by developing benchmarks targeted for computer architectures based on homomorphic operations.
Those benchmarks avoid termination problems while maintaining data privacy.


Below we delve into the three more widely used cryptosystems based on homomorphic encryption, RSA, El Gamal and Paillier.



\subsection{RSA Cryptosystem}\label{ss:rsa}
\fixme{
RSA (Rivest -- Shamir -- Adleman) is one of the first public-key cryptosystems and is widely used for secure data transmission.
In such a cryptosystem, the encryption key is public and it is different from the decryption key which is kept secret (private).
In RSA, this asymmetry is based on the practical difficulty of the factorization of the product of two large prime numbers, the ``factoring problem".
}


\subsection{El Gamal Cryptosystem}\label{ss:elgamal}
\fixme{
In cryptography, the ElGamal encryption system is an asymmetric key encryption algorithm for public-key cryptography which is based on the Diffieâ€“Hellman key exchange.
}

\fixme{
ElGamal encryption can be defined over any cyclic group \texttt{G}.
Its security depends upon the difficulty of a certain problem in \texttt{G} related to computing discrete logarithms.
}



\subsection{Paillier Cryptosystem}\label{ss:paillier}
\fixme{
The Paillier cryptosystem is a probabilistic asymmetric algorithm for public key cryptography.
The problem of computing n-th residue classes is believed to be computationally difficult.
The decisional composite residuosity assumption is the intractability hypothesis upon which this cryptosystem is based.
}



