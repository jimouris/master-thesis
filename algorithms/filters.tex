\begin{algorithm}[H]\fontfamily{lmss}
\caption{Privacy Preserving Constraint Mask}\label{a:filters-constraint-mask}
\begin{algorithmic}[1]
\renewcommand{\algorithmicrequire}{\textbf{Private Vars:}}
\Require ${\color{darkred}{array}}, {\color{darkred}{constraintMask}}, {\color{darkred}{eq}}, {\color{darkred}{constraintAttribute}}$
 % $\par \hspace{1.2cm}$

\Procedure{ConstraintMask}{${\color{darkred}{array}}[N][M], operation, constraintAttributes[C], $\par\hfill$ constraintOperators[C], constraintValues[C]$}

    \If {$operation = AND$}
        \State ${\color{darkred}{constraintMask}} \gets [\enc{1}, \enc{1}, \dots, \enc{1}]$ \Comment{{\small array initialized with $\enc{1}$}}
    \ElsIf {$operation = OR$}
        \State ${\color{darkred}{constraintMask}} \gets [\enc{0}, \enc{0}, \dots, \enc{0}]$ \Comment{{\small array initialized with $\enc{0}$}}
    \ElsIf {$operation = XOR$}
        \State ${\color{darkred}{constraintMask}} \gets [\enc{0}, \enc{0}, \dots, \enc{0}]$ \Comment{{\small array initialized with $\enc{0}$}}
    \EndIf

    \For{$c \in \{0, \dots, C-1\}$}\Comment{{\small $C$ is the number of the different constraints}}

        \State $constraintIndex \gets constraintAttributes[c]$

        \State ${\color{darkred}{constraintAttribute}} \gets {\color{darkred}{array}}[:, constraintIndex]$

        \State $constraintValue \gets constraintValues[c]$
        \State $constraintOperators \gets constraintOperators[c]$

        \If {$constraintOperators = GreaterThan$}
            \State ${\color{darkred}{eq}} \gets {\color{darkred}{constraintAttribute}} \hgt constraintValue$ \Comment{{\small ${\texttt{SIMD}; \color{darkred}{eq}}$ vector gets $\enc{1}$ at positions \par\hfill where the constraint holds, $\enc{0}$ otherwise}}
        \ElsIf {$constraintOperators = LessThan$}
            \State ${\color{darkred}{eq}} \gets {\color{darkred}{constraintAttribute}} \hlt constraintValue$
            % \Comment{{\small ${\texttt{SIMD}; \color{darkred}{eq}}$ vector gets $\enc{1}$  at positions where ${\color{darkred}{constraintAttribute}} \hlt constraintValue,  \enc{0}$ otherwise}}
        \ElsIf {$constraintOperators = Equal$}
            \State ${\color{darkred}{eq}} \gets {\color{darkred}{constraintAttribute}} \heq constraintValue$
            % \Comment{{\small ${\texttt{SIMD}; \color{darkred}{eq}}$ vector gets $\enc{1}$  at positions where ${\color{darkred}{constraintAttribute}} \heq constraintValue,  \enc{0}$ otherwise}}
        \EndIf

        \If {$operation = AND$}
            \State ${\color{darkred}{constraintMask}} \gets {\color{darkred}{constraintMask}} \hmul {\color{darkred}{eq}}$ \Comment{Applying the boolean operator between \par\hfill the constraints. {\small ${\texttt{SIMD}}$}}
        \ElsIf {$operation = OR$}
            \State ${\color{darkred}{constraintMask}} \gets {\color{darkred}{constraintMask}} \hplus {\color{darkred}{eq}}$
        \ElsIf {$operation = XOR$}
            \State ${\color{darkred}{constraintMask}} \gets {\color{darkred}{constraintMask}} \hplus (1-{\color{darkred}{eq}}) + (1-{\color{darkred}{constraintMask}}) * {\color{darkred}{eq}}$
        \EndIf

    \EndFor

    \State \textbf{return} {${\color{darkred}{constraintMask}}$}
\EndProcedure

\end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]\fontfamily{lmss}
\caption{Privacy Preserving Multi-Dimensional Histogram for Categorical Values with Filters}\label{a:filters-2d-histogram}
\begin{algorithmic}[1]
  \renewcommand{\algorithmicrequire}{\textbf{Private Vars:}}
  \Require ${\color{darkred}{array}}, {\color{darkred}{column}}, {\color{darkred}{positions}}, {\color{darkred}{histogram}}, {\color{darkred}{eq}}, {\color{darkred}{constraintMask}}$


  \Procedure{MultDimHistogramCategoricalFiltered}{${\color{darkred}{array}}[N][M], attributes[A], $\par\hfill$ Ps[A], operation, constraintAttributes[C], constraintOperators[C], $\par\hfill$ constraintValues[C]$}
      \State
      ${\color{darkred}{positions}} \gets [\enc{0}, \enc{0}, \dots, \enc{0}] $\Comment{{\small ${\color{darkred}{positions}}$ is an array initialized with $\enc{0}$}}

      \State ${\color{darkred}{constraintMask}} \gets \textsc{constraintMask}({\color{darkred}{array}}, operation, constraintAttributes, $\par\hfill$ constraintOperators, constraintValues)$

      \For{$a \in \{0, \dots, A-1\}$}

        \State $attribute \gets attributes[a]$

        \State ${\color{darkred}{column}} \gets {\color{darkred}{array}}[:, attribute]$ \Comment{{\small Slicing of a specific column of the ${\color{darkred}{array}}$ matrix}}

        \State $prod \gets \textsc{Product}(Ps[a+1:])$ \Comment{{\small Product of all $Ps$ elements from index $a+1$ onwards}}

        \State ${\color{darkred}{positions}} \gets {\color{darkred}{positions}} \hplus {\color{darkred}{column}} \hmul prod$

      \EndFor

      \State $length \gets \textsc{Product}(Ps)$

      \State ${\color{darkred}{histogram}} \gets [\enc{0}, \enc{0}, \dots, \enc{0}]$\Comment{{\small ${\color{darkred}{histogram}}$ is an array initialized with $\enc{0}$}}


      \For{$j \in \{0, \dots, length-1\}$}

        \State ${\color{darkred}{eq}} \gets ({\color{darkred}{positions}} \heq j) \hmul {\color{darkred}{constraintMask}}$
        \Comment{{\small ${\texttt{SIMD}; \color{darkred}{eq}}$ gets either $\enc{0}$ or $\enc{1}$}}

        \State ${\color{darkred}{histogram}}[j] \gets \textsc{Sum}({\color{darkred}{eq}})$

      \EndFor

      \State \textbf{return} {${\color{darkred}{histogram}}$}
  \EndProcedure

\end{algorithmic}
\end{algorithm}

